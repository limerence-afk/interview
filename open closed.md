# Абстракция `Shape`

  

Рассмотрим приложение, которое должно рисовать круги и квадраты в стандартном GUI. Круги и квадраты должны быть нарисованы в определенном порядке. В соответствующем порядке будет составлен список кругов и квадратов, программа должна пройтись в этом порядке по списку и нарисовать каждый круг или квадрат.

  

На C, используя техники процедурного программирования, не отвечающие принципу открытости-закрытости, мы могли бы решить эту задачу как показано на листинге 1. Здесь мы видим множество структур данных с одним и тем же первым элементом. Этот элемент — код типа, который идентифицирует структуру данных как круг или квадрат. Функция `DrawAllShapes` проходит по массиву указателей на эти структуры данных, узнавая код типа и затем вызывая соответствующую функцию (`DrawCircle`или `DrawSquare`).

  

``` c
//Листинг 1
//Решение проблемы Квадрат/Круг в процедурном стиле

enum ShapeType {circle, square}

struct Shape
{
    ShapeType itsType;
};
struct Circle
{
    ShapeType itsType;
    double itsRadius;
    Point itsCenter;
};

struct Square
{
    ShapeType itsType;
    double itsSide;
    Point itsTopLeft;
};
//
// реализованы в другом месте
//
void DrawSquare(struct Square*)
void DrawCircle(struct Circle*);
typedef struct Shape *ShapePointer;
void DrawAllShapes(ShapePointer list[], int n)
{
    int i;
    for (i=0; i<n; i++)
    {
        struct Shape* s = list[i];
        switch (s->itsType)
        {
            case square:
            DrawSquare((struct Square*)s);
            break;
            case circle:
            DrawCircle((struct Circle*)s);
            break;
        }
    }
}
```

  

Функция `DrawAllShapes` не отвечает принципу открытости-закрытости, потому что она не может быть «закрыта» от новых типов фигур. Если бы я захотел расширить эту функцию возможностью рисовать фигуры из списка, включающего треугольники, то мне потребовалось бы изменить функцию. Фактически я должен изменять функцию для каждого нового типа фигуры, который мне нужно рисовать.

  

Конечно, эта программа — просто пример. В реальной жизни `switch`-оператор из функции `DrawAllShapes` повторялся бы снова и снова в различных функциях по всему приложению и каждый бы делал что-то свое. Добавить новые фигуры в такое приложение — значит найти все места, где используются такие `switch`-операторы (или цепочки `if/else`), и добавить новую фигуру в каждое из них. Более того, очень маловероятно, что все `switch`-операторы и цепочки `if/else` будут так же хорошо структурированы, как в `DrawAllShapes`. Куда более вероятно, что предикаты в операторах `if` будут скомбинированы с логическими операторами или `case`-блоки `switch`-операторов будут скомбинированы так, чтобы «упростить» конкретное место в коде. Поэтому проблема нахождения и понимания всех мест, где нужно добавить новую фигуру, может быть нетривиальна.

  

В листинге 2 я покажу код, который демонстрирует решение задачи квадрат/круг, отвечающее принципу открытости-закрытости. Вводится абстрактный класс `Shape`. Этот абстрактный класс содержит одну чистую виртуальную функцию `Draw`. Классы `Circle` и `Square` являются наследниками класса `Shape`.

  

``` c
//Листинг 2
//Решение проблемы Квадрат/Круг в ООП-стиле

class Shape
{
public:
    virtual void Draw() const = 0;
};
class Square : public Shape
{
public:
    virtual void Draw() const;
};
class Circle : public Shape
{
public:
    virtual void Draw() const;
};
void DrawAllShapes(Set<Shape*>& list)
{
    for (Iterator<Shape*>i(list); i; i++)
        (*i)->Draw();
}
```

  

Заметьте: если мы захотим расширить поведение функции `DrawAllShapes` в листинге 2, чтобы рисовать новый вид фигур, то все, что нам нужно сделать, это добавить нового наследника класса `Shape`. Не нужно изменять функцию `DrawAllShapes`. Поэтому `DrawAllShapes` отвечает принципу открытости-закрытости. Ее поведение может быть расширено без изменений самой функции.

  

В реальном мире класс `Shape` содержал бы много других методов. И все же добавить новую фигуру в приложение все еще очень просто, так как все, что нужно сделать, — это ввести нового наследника и реализовать эти функции. Не нужно рыскать по всему приложению в поисках мест, требующих изменений.

  

Поэтому программы, отвечающие принципу открытости-закрытости, изменяются путем добавления нового кода, а не изменением уже существующего, в них не происходит каскадных изменений, свойственных программам, которые этому принципу не соответствуют.